import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

public class VulnerabilityParser {

  public static void main(String[] args) {
    System.out.println(parse("src/main/java/mywork/vulnerabilities.json"));
  }

  public static List<Vulnerability> parse(String filename) {
    try {
      Object obj = new JSONParser().parse(new FileReader(filename));
      JSONObject json = (JSONObject) obj;

      String version = json.get("version").toString();

      List<Object> vulnerabilities = (List<Object>) json.get("vulnerabilities");
      List<Vulnerability> vuls = vulnerabilities.stream().map(vul -> {
        try {
          Map<Object, Object> vulMap = (Map<Object, Object>) vul;
          Map cve = (Map) vulMap.get("cve");
          Map metrics = (Map) cve.get("metrics");
          List cvssMetrics = (List) metrics.get("cvssMetricV2");
          Map cvssMetric = (Map) cvssMetrics.get(0);
          Map cvssData = (Map) cvssMetric.get("cvssData");

          String loss_types = "";
          if (!cvssData.get("availabilityImpact").equals("NONE"))
            loss_types += "availability_loss,";

          if (!cvssData.get("integrityImpact").equals("NONE"))
            loss_types += "data_modification,";
          if (!cvssData.get("confidentialityImpact").equals("NONE"))
            loss_types += "data_loss,";
          if (loss_types.length() > 0)
            loss_types = loss_types.substring(0, loss_types.length() - 1);



          List configs = (List) cve.get("configurations");

          String soft = "";
          try {
            soft = (String) configs.stream()
                .map(c -> {
                  Map configMap = (Map) c;
                  List nodes = (List) configMap.get("nodes");
                  return nodes.stream()
                      .map(n -> {
                        Map nodeMap = (Map) n;
//                      System.out.println(nodeMap);
                        List cpe = (List) nodeMap.get("cpeMatch");
                        return cpe.stream()
                            .map(cpeMatch -> {
                              Map cpeMap = (Map) cpeMatch;
                              return cpeMap.get("criteria");
                            })
                            .reduce((c1, c2) -> c1 + "," + c2).get();
                      })
                      .reduce((c1, c2) -> c1 + "," + c2).get();
                })
                .reduce((c1, c2) -> c1 + "," + c2).get();
            if (soft.length() > 256) {
              soft = soft.substring(0, soft.indexOf(','));
            }
          } catch (NullPointerException e) {
          }

          List weaknesses = (List) cve.get("weaknesses");
          String weak = (String) weaknesses.stream()
              .map(w -> {
                Map weaknessMap = (Map) w;
                List descList = (List) weaknessMap.get("description");
                return (String) descList.stream().map(d -> {
                  Map descMap = (Map) d;
                  return descMap.get("value");
                }).reduce((v1, v2) -> v1 + ", " + v2).get();
              })
              .reduce((v1, v2) -> v1 + ", " + v2).get();

          String range = (String) cvssMetrics.stream().map((m -> {
                Map metricMap = (Map) m;
                Map data = (Map) metricMap.get("cvssData");
                return data.get("accessVector");
              }))
              .map(s -> {
                String res = "";
                switch((String)s) {
                  case "NETWORK":
                    res = "remoteExploit";
                  case "ADJACENT":
                    res = "lan";
                  case "LOCAL":
                    res = "user_action_req";
                  case "PHYSICAL":
                    res = "local";
                }
                return res;})
              .reduce((m1, m2) -> m1 + ", " + m2).get();

          return new Vulnerability(cve.get("id").toString(), soft, range, loss_types,
              Character.toLowerCase(cvssData.get("baseSeverity").toString().charAt(0)) + "",
              Character.toLowerCase(cvssData.get("accessComplexity").toString().charAt(0)) + "");
        } catch (NullPointerException | NoSuchElementException e) {
          return Vulnerability.nullVul();
        }
      }).collect(Collectors.toList());

      return vuls;
    } catch (Exception e) {
      e.printStackTrace();
      return new ArrayList<>();
    }
  }

  public static class Vulnerability {
    public String id;
    public String software;
    public String rge;
    public String lose_types;
    public String sev;
    public String access;

    public static Vulnerability nullVul() {
      return new Vulnerability("NULL", "", "", "", "", "");
    }

    public Vulnerability(String id, String software, String rge, String lose_types, String sev, String access) {
      this.id = id;
      this.software = software;
      this.rge = rge;
      this.lose_types = lose_types;
      this.sev = sev;
      this.access = access;
    }

    @Override
    public String toString() {
      return id + " " + " [" + software + "] " + rge + " [" + lose_types + "] " + sev + " " + access;
    }
  }

}
